<!DOCTYPE html>
<!-- The previous line tells the browser, that the page uses the HTML5 standard. -->

<html>
	<head>
		<title>3D Bottle Rotation</title>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

		<!-- The following meta line optimizes the site for mobile devices. It sets the viewport size
		to the screen size, so it will be displayed maximized, but unscaled. -->
		<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1">
        <link rel="stylesheet" href="bootstrap/bootstrap.css">
		<style type="text/css">
			body {
				/* Set the background color of the HTML page to black */
				background-color: #000000;

				/* Hide oversized content. This prevents the scroll bars. */
				overflow: hidden;
			}
            .content {
                background: transparent;
                z-index: 1000;
                padding: 10px;
                position: absolute;
                right: 0;
                margin-top:10px;
                margin-right: 50px;
            }
            .title {
                color: white;
            }
		</style>
    <script src="https://code.jquery.com/jquery-2.2.3.min.js"></script>
		<script src="bootstrap/bootstrap.js"></script>
		<!-- Include Three.js libraries -->
		<script src="js/three.js"></script>
		<script src="js/objloader.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/CanvasRenderer.js"></script>
		<script src="js/Projector.js"></script>
		<script src="js/window_resize.js"></script>
	</head>
	<body>
        <div class="content">
            <div class="title"><h2>2007 Woodlands Cabernet Merlot</h2></div>
            <div class="btn-group" role="group" aria-label="select-options">
                <div class="btn btn-success">Available</div>
                <div class="btn btn-primary">Add to Cart</div>
            </div>
        </div>

		<!-- This is the DIV element which will contain the WebGL canvas. To be identifiable lateron,
		the id 'WebGLCanvas' is applied to it. -->
		<div id="WebGLCanvas">

		<!-- This JavaScript block encloses the Three.js commands -->
		<script>
            var three = THREE;

            var scene = new three.Scene();
            var camera = new three.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);

						// Here, the position of the camera is tilted
            // camera.rotation.y = Math.PI/4;
            // camera.rotation.x = Math.PI/4;
            camera.rotation.z = -(Math.PI/4);
            camera.position.y = camera.position.y+40;
            camera.position.z = camera.position.z+100;

            var renderer = new three.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);

            document.body.appendChild(renderer.domElement);

            // Add light
            var ambient = new THREE.AmbientLight( 0x404040, 3 );
            scene.add( ambient );
            var light = new THREE.PointLight( 0xffffff, 7, 100 );
            light.position.set( 0,70,100 );
            scene.add( light );

            // Load texture

            // Load bottle object
            var objURL = 'models/full_bottle.obj';
            var loader4 = new THREE.OBJLoader();
            loader4.load( objURL, function ( object ) {
							var childrenToUpdate
							object.children[0].material.map = THREE.ImageUtils.loadTexture( 'labels/test_bottle.png');
							object.children[1].material.map = THREE.ImageUtils.loadTexture( 'labels/test_top.png');
							object.children[2].material.map = THREE.ImageUtils.loadTexture( 'labels/test_label.png');
              scene.add( object );

                var isDragging = false;
                var previousMousePosition = {
                    x: 0,
                    y: 0
                };

                $(renderer.domElement).on('mousedown', function(e) {
                    isDragging = true;
                })
                .on('mousemove', function(e) {
                    //console.log(e);
                    var deltaMove = {
                        x: e.offsetX-previousMousePosition.x,
                        y: e.offsetY-previousMousePosition.y
                    };

                    if(isDragging) {

												// Here, you can modify the speed of the spinning on drag ("toRadians(deltaMove.x * 1)")
                        var deltaRotationQuaternion = new three.Quaternion()
                            .setFromEuler(new three.Euler(
                                0,
															  toRadians(deltaMove.x * 1),
                                0,
                                'XYZ'
                            ));

                        object.quaternion.multiplyQuaternions(deltaRotationQuaternion, object.quaternion);
                    }

                    previousMousePosition = {
                        x: e.offsetX,
                        y: e.offsetY
                    };
                });

                $(document).on('mouseup', function(e) {
                    isDragging = false;
                });
						} );

            // shim layer with setTimeout fallback
            window.requestAnimFrame = (function(){
                return  window.requestAnimationFrame ||
                    window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    function(callback) {
                        window.setTimeout(callback, 1000 / 60);
                    };
            })();

            var lastFrameTime = new Date().getTime() / 1000;
            var totalGameTime = 0;
            function update(dt, t) {
                //console.log(dt, t);

                //camera.position.z += 1 * dt;
                //cube.rotation.x += 1 * dt;
                //cube.rotation.y += 1 * dt;

                setTimeout(function() {
                    var currTime = new Date().getTime() / 1000;
                    var dt = currTime - (lastFrameTime || currTime);
                    totalGameTime += dt;

                    update(dt, totalGameTime);

                    lastFrameTime = currTime;
                }, 0);
            }


						THREEx.WindowResize(renderer, camera);

            function render() {
                renderer.render(scene, camera);

                requestAnimFrame(render);
            }

            render();
            update(0, totalGameTime);

            function toRadians(angle) {
                return angle * (Math.PI / 180);
            }

            function toDegrees(angle) {
                return angle * (180 / Math.PI);
            }


		</script>
	</body>
</html>
